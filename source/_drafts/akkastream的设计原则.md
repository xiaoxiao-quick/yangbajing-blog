title: AkkaStream的设计原则
tags:
- akka
- akka stream
---

# 用户期望的Akka Stream是什么？

1. 所有功能在API中都是明确的，没有魔法。
2. 最高组合性，组件每一部分的功能都得以保留。
3. 详尽领域模型的分布式流处理，这意味着我们提供完善的工具来描述任何流处理拓扑。

这意味着，提供所有的工具来表达任何流处理拓扑。对该领域的所有基本方面（背压、缓冲、转换、故障恢复等）进行建模，并且用户构建的任何内容在更大的上下文中都是可重用的。

# Akka Stream 不发送元素到 dead letter office

仅提供可依赖的特性的一个重要后果是，Akka Streams不能保证通过处理拓扑的所有对象都被处理。由于许多原因，元素可以被删除：

1. 用户代码可以在 `map()` 阶段消耗一个元素，并产生一个完全不同的结果。
2. 公共流操作可删除元素，如：`take/drop/filter/conflate/buffer/...`。
3. 流发生故障时将不等待处理完成而直接结束，所有未处理的元素都将被丢弃。
4. 流取消传播到上游（例如一个 `take` 操作）导致上游处理步骤被终止而不处理所有的输入。

这意味着发送到流的JVM对象需要被清理，用户需要确保在Akka Streams之外进行。（如：在超时后清理它们，或者在它们做为结果从流输出时，或者使用其它方法，如：`finalizers`）。

# 最终实现约束

组合性需要部分流拓扑的可重用性，这导致我们将描述数据流的提升方法（部分）图作为组合：source、flows（类似管道）、和sink。这些构建块可自由共享，可自由组合它们形成更大的一个图。因此，这些片段的表示必须是一个不可变的蓝图（blueprint），其在显式的步骤中被物化后以启动流处理。由此产生的流处理引擎在具有由蓝图制定的固定拓扑结构也是不可变的。动态网络需要通过显式地使用Reactive Streams接口来插入不同的引擎。

物化过程通常会创建特定对象，这些对象在处理引擎执行时是有用的。例如关闭或提取度量指标（metrics）。这意味着物化函数将产生图的一个物化值结果。



