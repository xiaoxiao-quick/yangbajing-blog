title: Scala实战：使用Actor来聚合多个API
date: 2016-02-27 18:30:59
categories: scala
tags:
- actor
- akka
- scala
- play
---

项目中会遇到一个很常见的需求，从多个数据源或相同数据源的不同API获取数据，汇总整理后再发送给客户或存库等其它操作。这是一个很常见的需求，需要注意以下几点

1. 可异步从数据源请求
2. 请求可能有相互依赖
3. 可记录每个请求日志：访问时间
4. 所有请求汇总后返回数据
5. 客户端可控制访问超时
6. 优雅的处理请求错误

这里，我使用[Play 2](https://playframework.com/)进行演示。

## 解决方案

先谈谈之前列的6点的解决方案，之后我们再编码实现。

**1. 可异步从数据源请求**

使用Play自带的[WSClient]()组件，我们可以很方便的发送HTTP请求，它基于AsyncHttpClient构建了一套便捷的Scala API，返回Future。使用WSClient可以很好的实现异步请求问题。

**2. 请求可能相互依赖**

当从多个数据源汇总数据时，有时候并不是直接向所有数据源一股脑的发送HTTP请求，等所以请求完成再汇总就完了。很多时候它们之间可能是有依赖关系的。比如我们需要发送：A, B, C 3个请求，C需要依赖A, B的返回结果做为请求参数，我们不想使用阻塞的方式串行等A, B返回。在Scala里可以使用for comprehension为解决，不过这里我们会使用基于Actor的消息机制来解决这个问题。

**3. 可记录每个请求日志：访问时间**

我们可以在使用 WSClient 发送请求前记录下当前时间，再返回的Future对象onComplete时记录结果时间，两者相减就是每个请求的访问时间了。

**4. 所有请求汇总后返回数据**

这个问题比较容易解决，在我们的方案中。每个请求返回的结果都会能过消息发送给Actor，在Actor内部保存数据并汇总。对同一个Actor实例的消息访问，Akka会保证它是顺序的。

**5. 客户端可控制访问超时**

这里的客户端可控制访问超时是指无论向后端的API请求成功与否，都应该在单位时间内向调用方返回一个结果：成功或失败。

这里在实现上，有多种方式来设置这个超时时间。对于HTTP请求本身，我们可以设置ConnectTimeout和RequestTimeout。而对于总的请求任务来说，我们需要设置一个定时器来记录超时时间。

在向Actor发送消息时，有两种形式：! (tell)和 ? (ask)，当使用 ask 形式时，我们可以设置一个 Timeout ，当超时时间到后 Future 会返回 Failure 类型。

**6. 优雅的处理请求错误**

Future 提供了 .recover 方法来允许用户可以从异常中恢复，将一个 Failure 类型的Future 包装成一个 Success 返回。而在第5步当真的出现访问超时情况时，我们可以向Actor发送PoisonPill消息“毒死” actor ，或者可以自定义一个 Stop 消息手动控制 actor 的生命周期。

## 实现

好了，说了这么多，我们来看看在Scala中怎么实现吧。